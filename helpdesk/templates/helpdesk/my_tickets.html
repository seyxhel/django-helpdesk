{% extends "helpdesk/base.html" %}{% load i18n %}

{% block helpdesk_title %}{% trans "My Tickets" %}{% endblock %}

{% block helpdesk_breadcrumb %}
<li class="breadcrumb-item active">{% trans "My Tickets" %}</li>
<li id="last-ticket-breadcrumb" class="breadcrumb-item" style="display:none"></li>
{% endblock %}

{% block helpdesk_body %}
<h2 class="sr-only">{% trans "My Tickets" %}</h2>

<style>
    /* Ensure the main content sits nicely next to the sidebar when present */
    @media(min-width: 768px) {
        #content-wrapper .container-fluid { padding-left: 22px; }
        
    }
</style>

<div class="container mt-4">
    <div class="d-flex justify-content-end mb-2">
        <div class="btn-group" role="group" aria-label="Ordering">
            <button id="orderToggle" class="btn btn-secondary" data-order="desc">Order: Newest</button>
        </div>
    </div>

    <div class="row mb-3">
        <div class="col-md-4">
            <input id="queueSearch" class="form-control" placeholder="Search queues or click to see all" autocomplete="off" />
            <div id="queueDropdown" class="list-group" style="position:absolute;z-index:1000;display:none;max-height:200px;overflow:auto;width:100%;"></div>
        </div>
        <div class="col-md-3">
            <select id="statusFilter" class="form-control">
                <option value="">All statuses</option>
                {% for code,label in status_choices %}
                <option value="{{ code }}">{{ label }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="col-md-5 text-right">
            <!-- pagination will be aligned to right -->
        </div>
    </div>

    <div class="table-responsive">
    <table class="table table-striped" id="ticketsTable">
        <thead>
            <tr>
                <th>{% trans "Title" %}</th>
                <th>{% trans "Queue" %}</th>
                <th>{% trans "Status" %}</th>
                <th>{% trans "Created" %}</th>
                <th>{% trans "Last updated" %}</th>
            </tr>
        </thead>
        <tbody>
            <!-- Rows will be added here dynamically using jQuery -->
        </tbody>
    </table>
    </div>
    <nav aria-label="{% trans 'Page navigation' %}">
        <ul class="pagination justify-content-end" id="pagination">
            <!-- Pagination buttons will be added here dynamically -->
        </ul>
    </nav>
</div>

<script>
// don't use jquery's document ready but rather the more basic window load
// because we need to wait for the page to load before we can fetch the tickets
window.addEventListener('load', function()
 {
    let cachedQueues = [];
    // Map of status code -> label for strict client-side filtering when needed
    const statusMap = {
        {% for code,label in status_choices %}
        "{{ code }}": "{{ label }}"{% if not forloop.last %},{% endif %}
        {% endfor %}
    };

    function fetchQueues(q = ''){
        // Try the router-backed URL first, then fall back to common paths.
        const candidates = [
            '{% url "helpdesk:queue-list" %}',
            '/api/queues/',
            '/helpdesk/api/queues/'
        ];
        let tried = 0;
        function tryOne(){
            if(tried >= candidates.length){
                console.warn('fetchQueues: no endpoint succeeded');
                cachedQueues = [];
                renderQueueDropdown(q);
                return;
            }
            const url = candidates[tried++];
            $.get(url)
                .done(function(data){
                    // If the server returned HTML (login page), detect and abort
                    if(typeof data === 'string' && data.trim().startsWith('<')){
                        console.warn('fetchQueues: got HTML response from', url);
                        tryOne();
                        return;
                    }
                    cachedQueues = data;
                    renderQueueDropdown(q);
                })
                .fail(function(xhr, status, err){
                    console.warn('fetchQueues failed for', url, status, err, xhr.status);
                    tryOne();
                });
        }
        tryOne();
    }

    function renderQueueDropdown(filter){
        const container = $('#queueDropdown');
        container.empty();
        const f = (filter || '').toLowerCase();
        let shown = 0;
        cachedQueues.forEach(function(q){
            if(!f || q.title.toLowerCase().indexOf(f) !== -1){
                shown++;
                container.append(`<a href="#" class="list-group-item list-group-item-action" data-id="${q.id}">${q.title}</a>`);
            }
        });
        if(shown > 0){
            container.show();
        } else {
            container.hide();
        }
    }

    function fetchTickets(page = 1) {
        const ordering = $('#orderToggle').data('order') || 'desc';
        const status = $('#statusFilter').val() || '';
        const queueId = $('#queueSearch').data('queue-id') || '';
        const endpoint = '{% url "helpdesk:user_tickets-list" %}?page=' + page + '&ordering=' + ordering + '&page_size=8' + (status ? '&status=' + status : '') + (queueId ? '&queue=' + queueId : '');
        console.debug('fetchTickets endpoint', endpoint);

        $.get(endpoint)
            .done(function(data){
                // Detect HTML responses (likely a login redirect) and log useful info
                if(typeof data === 'string' && data.trim().startsWith('<')){
                    console.error('fetchTickets: received HTML (probably unauthenticated). Check network tab for', endpoint);
                    return;
                }
                $('#ticketsTable tbody').empty();
                console.debug('fetchTickets response', data);
                // If a status is selected, apply a strict client-side filter by label
                const selectedStatus = $('#statusFilter').val() || '';
                let results = data.results || [];
                if(selectedStatus){
                    const label = statusMap[selectedStatus] || null;
                    if(label){
                        results = results.filter(function(ticket){
                            // ticket.status from the public serializer is the label (e.g. "Open")
                            return String(ticket.status) === String(label);
                        });
                    }
                }
                results.forEach(function(ticket) {
                ticket.title = $('<div>').html(ticket.title).html();
                $('#ticketsTable tbody').append(`
                    <tr>
                        <td>
                            <a href='/view/?ticket=${ticket.id}&email=${ticket.submitter}&key=${ticket.secret_key}'>${ticket.title}</a>
                        </td>
                        <td>${ticket.queue.title}</td>
                        <td>${ticket.status}</td>
                        <td>${ticket.created}</td>
                        <td>${ticket.last_followup || ''}</td>
                    </tr>
                `);
            });

            $('#pagination').empty();
            // compute total pages; prefer server-side count when server applied the
            // status filter. If we applied client-side filtering and the server did
            // not, derive the total from the filtered results to avoid empty pages.
            const pageSize = 8;
            let totalCount = data.count || 0;
            if(selectedStatus){
                const label = statusMap[selectedStatus] || null;
                if(label){
                    // Check whether server already returned only matching-status items
                    const allMatch = (data.results || []).every(function(t){ return String(t.status) === String(label); });
                    if(!allMatch){
                        // server didn't filter; use client-side result count
                        totalCount = (results || []).length;
                    }
                }
            }
            const totalPages = Math.max(1, Math.ceil((totalCount || 0) / pageSize));
            const currentPage = parseInt(page) || 1;
            for (let i = 1; i <= totalPages; i++) {
                $('#pagination').append(`
                    <li class="page-item ${i === currentPage ? 'active' : ''}">
                        <a class="page-link" href="#" data-page="${i}">${i}</a>
                    </li>
                `);
            }

            })
            .fail(function(xhr, status, err){
                console.error('fetchTickets failed', status, err, xhr.status, xhr.responseText && xhr.responseText.substring(0,200));
            });
    }

    // Load last viewed ticket from localStorage (set by public view)
    (function populateLastTicketBreadcrumb(){
        try{
            const last = JSON.parse(localStorage.getItem('helpdesk_last_public_ticket') || 'null');
            if(last && last.url && last.title){
                $('#last-ticket-breadcrumb').html(`<a href="${last.url}">${last.title}</a>`).show();
            }
        }catch(e){/* ignore */}
    })();

    // Toggle ordering
    $('#orderToggle').on('click', function(){
        const current = $(this).data('order') === 'asc' ? 'desc' : 'asc';
        $(this).data('order', current);
        $(this).text(current === 'asc' ? 'Order: Oldest' : 'Order: Newest');
        fetchTickets(1);
    });

    // Queue search interactions
    // Always fetch queues when the user clicks or focuses the input so they
    // reliably see the full list on demand.
    $('#queueSearch').on('focus click', function(){
        fetchQueues('');
    });
    $('#queueSearch').on('input', function(){
        const v = $(this).val();
        if(cachedQueues.length === 0){ fetchQueues(v); }
        else { renderQueueDropdown(v); }
    });
    // Pick a queue
    $(document).on('click', '#queueDropdown a', function(e){
        e.preventDefault();
        const id = $(this).data('id');
        const title = $(this).text();
        $('#queueSearch').val(title).data('queue-id', id);
        $('#queueDropdown').hide();
        fetchTickets(1);
    });
    // Clear queue when emptying input
    $('#queueSearch').on('keydown', function(e){
        if(e.key === 'Backspace' && $(this).val().length <= 1){
            $(this).data('queue-id', '');
        }
    });

    // Hide dropdown when clicking outside or pressing Escape
    $(document).on('click', function(e){
        if(!$(e.target).closest('#queueSearch, #queueDropdown').length){
            $('#queueDropdown').hide();
        }
    });

    $(document).on('keydown', function(e){
        if(e.key === 'Escape'){
            $('#queueDropdown').hide();
            $('#queueSearch').blur();
        }
    });

    // Status filter
    $('#statusFilter').on('change', function(){ fetchTickets(1); });

    // Pagination click
    $(document).on('click', '#pagination a', function(e){
        e.preventDefault();
        const page = parseInt($(this).data('page')) || 1;
        fetchTickets(page);
    });

    // initial load
    fetchTickets();
});

</script>

{% endblock %}
